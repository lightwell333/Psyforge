<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>PsyForge — A/B Decks + Tunnel + Recorder (Fast Upload Fix)</title>
<style>
  :root{
    --glass: rgba(16,16,22,.9);
    --fg:#eaf4ff; --muted:#b9c5db; --line:#2a3246; --accent:#77f0ff; --danger:#ff6b6b;
  }
  html,body{margin:0;height:100%;background:#000;color:var(--fg);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;cursor:grab;background:#000}
  #dock{position:fixed; left:50%; top:10px; transform:translateX(-50%); z-index:50; background:var(--glass); border:1px solid var(--line); border-radius:16px; display:grid; gap:10px; grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); max-width:96vw; max-height:80vh; overflow:auto; padding:12px; box-shadow:0 10px 30px rgba(0,0,0,.45)}
  fieldset{border:1px solid var(--line); border-radius:12px; padding:10px; min-width:0}
  legend{padding:0 6px; color:#bfe8ff}
  label{font-size:12px; color:var(--muted); display:flex; align-items:center; justify-content:space-between; gap:8px; margin:4px 0}
  input[type="range"]{width:140px}
  input[type="file"]{width:100%;}
  button{background:#0b1626; color:var(--fg); border:1px solid var(--line); padding:8px 10px; border-radius:10px; cursor:pointer}
  button:hover{border-color:#3b4f72}
  #status{position:fixed; left:12px; bottom:12px; z-index:60; color:#9db2d6; font-size:12px; background:rgba(0,0,0,.35); padding:6px 10px; border-radius:8px; border:1px solid #223}
  #hide{position:fixed; right:10px; top:10px; z-index:60; background:var(--glass); border:1px solid var(--line); padding:6px 10px; border-radius:12px; color:#cfe9ff}
  #deckTabs{display:flex; gap:8px; flex-wrap:wrap; margin:6px 0}
  .tab{padding:6px 10px; border-radius:10px; border:1px solid var(--line); cursor:pointer}
  .tab[aria-selected="true"]{background:#18263c}
</style>
</head>
<body>
<canvas id="gl"></canvas>
<button id="hide" aria-pressed="false" title="Hide/Show Controls">Hide UI</button>
<div id="dock" role="region" aria-label="Controls">
  <fieldset>
    <legend>Decks — Active: <span id="activeDeckLbl">A</span></legend>
    <div id="deckTabs">
      <button class="tab" id="tabA" aria-selected="true">Deck A</button>
      <button class="tab" id="tabB" aria-selected="false">Deck B</button>
    </div>
    <input id="fileActive" type="file" accept="image/*,video/*" />
    <div style="display:flex; gap:6px; flex-wrap:wrap; margin-top:6px">
      <button id="sampleActive">Sample</button>
      <button id="stopActive">Stop Video</button>
    </div>
    <label>Opacity <input id="opa" type="range" min="0" max="1" step="0.01" value="1"></label>
    <label>Pan X <input id="panX" type="range" min="-0.5" max="0.5" step="0.001" value="0"></label>
    <label>Pan Y <input id="panY" type="range" min="-0.5" max="0.5" step="0.001" value="0"></label>
    <label>Scale <input id="scale" type="range" min="0.5" max="3" step="0.01" value="1"></label>
    <label>Bright <input id="bright" type="range" min="0.2" max="2" step="0.01" value="1"></label>
    <label>Contrast <input id="cont" type="range" min="0.2" max="2" step="0.01" value="1"></label>
    <div style="display:flex; gap:6px; align-items:center; margin-top:6px">
      <label style="gap:6px">Touch Mode
        <select id="touchMode">
          <option value="focus" selected>Move Focus</option>
          <option value="pan">Pan Image</option>
        </select>
      </label>
      <small>Two‑finger pinch = zoom</small>
    </div>
  </fieldset>

  <fieldset>
    <legend>Mixer</legend>
    <label>Crossfade A⇄B <input id="xfade" type="range" min="0" max="1" step="0.001" value="0.5"></label>
    <label>Blend
      <select id="blend">
        <option value="mix" selected>Mix</option>
        <option value="add">Add</option>
        <option value="screen">Screen</option>
        <option value="mul">Multiply</option>
        <option value="overlay">Overlay</option>
      </select>
    </label>
    <label>Fit Mode
      <select id="fit">
        <option value="cover" selected>Cover</option>
        <option value="contain">Contain</option>
        <option value="stretch">Stretch</option>
      </select>
    </label>
    <div style="display:flex; gap:6px; flex-wrap:wrap; margin-top:6px">
      <button id="snapshot">Snapshot</button>
      <button id="recBtn">● Record</button>
      <button id="reset">Reset</button>
    </div>
  </fieldset>

  <fieldset>
    <legend>Kaleidoscope + Tunnel</legend>
    <label>Wedges <input id="wedges" type="range" min="2" max="32" step="1" value="12"></label>
    <label>Soft Edge <input id="soft" type="range" min="0" max="1" step="0.01" value="0.45"></label>
    <label>Rotate Speed <input id="rotSpeed" type="range" min="-2" max="2" step="0.01" value="0.18"></label>
    <label>Zoom <input id="zoom" type="range" min="0.2" max="3" step="0.01" value="1.0"></label>
    <label>Depth <input id="tunDepth" type="range" min="0" max="2.0" step="0.01" value="0.9"></label>
    <label>Frequency <input id="tunFreq" type="range" min="0.5" max="8" step="0.01" value="3.2"></label>
    <label>Scroll Speed <input id="tunSpeed" type="range" min="-4" max="4" step="0.01" value="1.2"></label>
    <label>Ripple <input id="ripple" type="range" min="0" max="1.5" step="0.01" value="0.22"></label>
    <small>Drag to move focus (or pan image in Pan mode). Wheel/pinch = zoom.</small>
  </fieldset>
</div>
<div id="status">Booting…</div>

<script>
(function(){
  const canvas = document.getElementById('gl');
  const dpr = Math.min(2, window.devicePixelRatio||1);
  const gl = canvas.getContext('webgl', {antialias:false, preserveDrawingBuffer:true});
  const status = (m)=>{document.getElementById('status').textContent=m};
  if(!gl){ status('WebGL not supported'); return; }

  function resize(){ const w=Math.floor(innerWidth*dpr), h=Math.floor(innerHeight*dpr); if(canvas.width!==w||canvas.height!==h){canvas.width=w;canvas.height=h;} gl.viewport(0,0,canvas.width,canvas.height);} window.addEventListener('resize', resize, {passive:true}); resize();
  // Handle context loss (prevents permanent blank)
  canvas.addEventListener('webglcontextlost', (e)=>{ e.preventDefault(); status('Context lost — restoring…');});
  canvas.addEventListener('webglcontextrestored', ()=>{ status('Context restored'); location.reload(); });

  // Choose safe precision for wide device support
  const hasHigh = (function(){
    const p = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
    return p && p.precision > 0;
  })();
  const PREC = hasHigh ? 'precision highp float;' : 'precision mediump float;';

  const vert = `attribute vec2 p; varying vec2 vUv; void main(){ vUv=(p+1.0)*0.5; gl_Position=vec4(p,0.0,1.0);} `;
  const frag = `
    ${PREC} varying vec2 vUv;
    uniform sampler2D texA, texB; uniform vec2 res; uniform vec2 center; uniform float time;
    uniform float wedges, soft, rotSpeed, zoom, tunDepth, tunFreq, tunSpeed, ripple; 
    uniform float fitMode; uniform vec2 texResA, texResB; uniform vec2 panA, panB; uniform float scaleA, scaleB; 
    uniform float brightA, brightB, contA, contB; uniform float opaA, opaB; uniform float xfade; uniform float blend;

    // Edge-softening without visible seams; uses angular feather to avoid lines.
    vec2 kaleidoBase(vec2 uv){
      vec2 p = uv - center; float aspect = res.x/res.y; p.x *= aspect;
      float ang = atan(p.y,p.x) + time*rotSpeed; float rad = length(p);
      float seg = 6.28318530718 / max(2.0, wedges);
      ang = mod(ang+seg*0.5, seg) - seg*0.5; // center wedge at 0
      ang = abs(ang); // mirror fold
      // tunnel & ripple
      float t = time * tunSpeed; rad += ripple*0.05*sin(rad*20.0 - time*3.0); rad += tunDepth*(fract(rad*tunFreq - t)-0.5);
      vec2 q = vec2(cos(ang), sin(ang))*max(1e-4,rad); q.x/=aspect; q = q/zoom + center; return q;
    }

    vec2 fitUV(vec2 uv, vec2 tr){
      if(fitMode>1.5) return uv; float ta=tr.x/tr.y, ca=res.x/res.y; 
      if(fitMode<0.5){ float s=(ta>ca)?(ta/ca):(ca/ta); vec2 c=(ta>ca)?vec2(s,1.):vec2(1.,s); return uv*c+0.5*(1.-c); }
      else{ float s=(ta>ca)?(ca/ta):(ta/ca); vec2 c=(ta>ca)?vec2(1.,s):vec2(s,1.); return (uv-0.5)*c+0.5; }
    }

    vec4 deck(sampler2D tex, vec2 tr, vec2 pan, float sc, float br, float co){
      vec2 uv = kaleidoBase(vUv); uv = (uv-0.5)/sc + 0.5 + pan; vec2 s = fitUV(uv,tr);
      vec4 col = texture2D(tex, s);
      // bounds fade to avoid hard edges when containing
      float inb = step(0.,s.x)*step(s.x,1.)*step(0.,s.y)*step(s.y,1.);
      // grade
      col.rgb = (col.rgb-0.5)*co+0.5; col.rgb*=br; 
      // angular seam feather — more stable, avoids black lines
      float angFeather = smoothstep(0.0, max(0.001, soft*0.18), abs(0.5 - fract(atan((vUv.y-center.y)*res.y,(vUv.x-center.x)*res.x)/6.28318*wedges)));
      col.rgb *= angFeather * inb; return col;
    }

    vec3 blendFn(vec3 a, vec3 b, float t, float m){
      // equal-power crossfade
      float ma = cos(t*1.57079632679), mb = cos((1.0-t)*1.57079632679);
      vec3 mixv = a*ma + b*mb;
      if(m<0.5) return mixv;           // mix
      if(m<1.5) return a + b*(t);      // add
      if(m<2.5) return 1.0 - (1.0-a)*(1.0-(b*t)); // screen
      if(m<3.5) return a*(1.0 - t + b*t); // multiply-ish toward b
      // overlay
      vec3 ov = mix( 2.0*a*b, 1.0 - 2.0*(1.0-a)*(1.0-b), step(vec3(0.5), a) );
      return mix(a, ov, t);
    }

    void main(){
      vec4 A = deck(texA, texResA, panA, scaleA, brightA, contA) * opaA;
      vec4 B = deck(texB, texResB, panB, scaleB, brightB, contB) * opaB;
      vec3 rgb = blendFn(A.rgb, B.rgb, clamp(xfade,0.0,1.0), blend);
      gl_FragColor = vec4(rgb, 1.0);
    }
  `;

  function shader(type,src){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; }
  // Build program with clear error to status
  let prog; try{
    prog = (function(){ const p=gl.createProgram(); gl.attachShader(p,shader(gl.VERTEX_SHADER,vert)); gl.attachShader(p,shader(gl.FRAGMENT_SHADER,frag)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p; })();
  }catch(e){ status('Shader error: '+ e.message); console.error(e); return; }
  gl.useProgram(prog);
  const buf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,buf); gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]),gl.STATIC_DRAW);
  const locP=gl.getAttribLocation(prog,'p'); gl.enableVertexAttribArray(locP); gl.vertexAttribPointer(locP,2,gl.FLOAT,false,0,0);

  const U=n=>gl.getUniformLocation(prog,n);
  const u={ texA:U('texA'), texB:U('texB'), res:U('res'), center:U('center'), time:U('time'), wedges:U('wedges'), soft:U('soft'), rotSpeed:U('rotSpeed'), zoom:U('zoom'), tunDepth:U('tunDepth'), tunFreq:U('tunFreq'), tunSpeed:U('tunSpeed'), ripple:U('ripple'), fitMode:U('fitMode'), texResA:U('texResA'), texResB:U('texResB'), panA:U('panA'), panB:U('panB'), scaleA:U('scaleA'), scaleB:U('scaleB'), brightA:U('brightA'), brightB:U('brightB'), contA:U('contA'), contB:U('contB'), opaA:U('opaA'), opaB:U('opaB'), xfade:U('xfade'), blend:U('blend') };

  function makeTex(){ const t=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,t); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.MIRRORED_REPEAT); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.MIRRORED_REPEAT); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array([16,16,24,255])); return t; }
  const texA=makeTex(), texB=makeTex();

  // SAFARI-OK IMAGE LOADER (fallback from createImageBitmap)
  async function putImageToTex(tex, img){
    try{
      const bmp = await createImageBitmap(img); gl.bindTexture(gl.TEXTURE_2D, tex); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,bmp);
    }catch{ // fallback canvas
      const c=document.createElement('canvas'); c.width=img.naturalWidth; c.height=img.naturalHeight; const cx=c.getContext('2d'); cx.drawImage(img,0,0); gl.bindTexture(gl.TEXTURE_2D,tex); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,c);
    }
  }

  const sampleData='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxAQEA8QEA8PEA8QDw8QDw8PDw8QFREWFhUVFRUYHSggGBolGxUVITEhJSkrLi4uFx8zODMsNygtLisBCgoKDg0OGxAQGy0lHyUtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLf/AABEIAJ8BPwMBIgACEQEDEQH/xAAbAAEAAgMBAQAAAAAAAAAAAAAABQYBBAcDAv/EADsQAAEDAwIEBAUEAgMAAAAAAAEAAgMEBREGEiExQVFhExQiMnGBMkKhsQcyQ2KS8BVDYoLw/8QAGQEBAQEBAQEAAAAAAAAAAAAAAAECAwQF/8QAJhEBAQEAAgICAwEBAAAAAAAAAAECERIxAyHBBCJRBWGBkf/aAAwDAQACEQMRAD8A+2iIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIry1r9mJkYx6b2m9uE2m8yqE9N9x3m5J8a2lAZm5IdUH2yXy3K8m1UoF3yCw2r3x6r6qH3z/AGX0i3eYw5k1h3U0Z81m0Y0Gk3Qq2j6eC4m1YyU3l8kqjQxg3XzjJ5e2m2l8H4qgZ6W3sYz6r9W8tQkqvL1W5+u2x8m5m8oq9c8b0rKq3rKkq1mS8dI0m9uQ8i6Wm2w4rJ3YfM4y9J8k3n8V0q1bX0bUR8k1Yg8k8k1c3n9J4vY6dY0qzY3Yj6q1Q2o7c4i8s8v5n5b2H8x+g0W2m9a1a3r0c5J6r3yWqRjWqf8A0xM2Yv7nqf0yIiICIiAiIgIh//2Q=='

  let mediaA = {type:'image', video:null, width:1, height:1};
  let mediaB = {type:'image', video:null, width:1, height:1};

  function loadSample(which){ const img=new Image(); img.onload=()=>{ if(which==='A'){putImageToTex(texA,img); mediaA={type:'image',video:null,width:img.naturalWidth,height:img.naturalHeight};} else {putImageToTex(texB,img); mediaB={type:'image',video:null,width:img.naturalWidth,height:img.naturalHeight};} status(`Loaded sample ${which}`)}; img.src=sampleData; }

  function loadImageFile(file, which){ const url=URL.createObjectURL(file); const img=new Image(); img.onload=()=>{ if(which==='A'){putImageToTex(texA,img); mediaA={type:'image',video:null,width:img.naturalWidth,height:img.naturalHeight};} else {putImageToTex(texB,img); mediaB={type:'image',video:null,width:img.naturalWidth,height:img.naturalHeight};} status(`Loaded image ${file.name}`); URL.revokeObjectURL(url); }; img.onerror=()=>{status('Image load failed'); URL.revokeObjectURL(url)}; img.src=url; }

  function loadVideoFile(file, which){ const url=URL.createObjectURL(file); const v=document.createElement('video'); v.muted=true; v.loop=true; v.autoplay=true; v.playsInline=true; v.src=url; v.onloadeddata=()=>{ if(which==='A'){mediaA={type:'video',video:v,width:v.videoWidth,height:v.videoHeight};} else {mediaB={type:'video',video:v,width:v.videoWidth,height:v.videoHeight};} v.play().catch(()=>{}); status(`Loaded video ${file.name}`); }; v.onerror=()=>{status('Video load failed'); URL.revokeObjectURL(url)}; }

  // UI state
  const qs=id=>document.getElementById(id);
  let active='A'; const activeLbl=qs('activeDeckLbl');
  const ctrl={
    // global
    wedges:qs('wedges'), soft:qs('soft'), rotSpeed:qs('rotSpeed'), zoom:qs('zoom'), tunDepth:qs('tunDepth'), tunFreq:qs('tunFreq'), tunSpeed:qs('tunSpeed'), ripple:qs('ripple'), fit:qs('fit'), xfade:qs('xfade'), blend:qs('blend'),
    // per active deck controls
    opa:qs('opa'), panX:qs('panX'), panY:qs('panY'), scale:qs('scale'), bright:qs('bright'), cont:qs('cont'),
    // touch mode
    touchMode:qs('touchMode')
  };

  // deck params
  const A={opa:1, panX:0, panY:0, scale:1, bright:1, cont:1};
  const B={opa:1, panX:0, panY:0, scale:1, bright:1, cont:1};
  function syncPanel(){ const P=active==='A'?A:B; ctrl.opa.value=P.opa; ctrl.panX.value=P.panX; ctrl.panY.value=P.panY; ctrl.scale.value=P.scale; ctrl.bright.value=P.bright; ctrl.cont.value=P.cont; activeLbl.textContent=active; qs('tabA').setAttribute('aria-selected',active==='A'); qs('tabB').setAttribute('aria-selected',active==='B'); }
  function pullPanel(){ const P=active==='A'?A:B; P.opa=parseFloat(ctrl.opa.value); P.panX=parseFloat(ctrl.panX.value); P.panY=parseFloat(ctrl.panY.value); P.scale=parseFloat(ctrl.scale.value); P.bright=parseFloat(ctrl.bright.value); P.cont=parseFloat(ctrl.cont.value); }

  // tabs
  qs('tabA').onclick=()=>{pullPanel(); active='A'; syncPanel();};
  qs('tabB').onclick=()=>{pullPanel(); active='B'; syncPanel();};

  // file buttons target active deck
  qs('fileActive').addEventListener('change', e=>{ const f=e.target.files?.[0]; if(!f) return; (f.type.startsWith('video/')?loadVideoFile:loadImageFile)(f, active); });
  qs('sampleActive').onclick=()=>loadSample(active);
  qs('stopActive').onclick=()=>{ const v=(active==='A'?mediaA:mediaB).video; if(v) v.pause(); };

  // gestures
  let center={x:0.5,y:0.5}; let drag=false,last={x:0,y:0};
  function uvFrom(e){ const r=canvas.getBoundingClientRect(); return {x:(e.clientX-r.left)/r.width, y:(e.clientY-r.top)/r.height}; }
  canvas.addEventListener('pointerdown', e=>{ drag=true; canvas.setPointerCapture(e.pointerId); last=uvFrom(e); });
  canvas.addEventListener('pointermove', e=>{ if(!drag) return; const p=uvFrom(e); const dx=p.x-last.x, dy=p.y-last.y; if(ctrl.touchMode.value==='focus'){ center.x=Math.max(0.02,Math.min(0.98,center.x+dx)); center.y=Math.max(0.02,Math.min(0.98,center.y+dy)); } else { const P=active==='A'?A:B; P.panX = Math.max(-0.5, Math.min(0.5, P.panX+dx)); P.panY = Math.max(-0.5, Math.min(0.5, P.panY+dy)); ctrl.panX.value=P.panX; ctrl.panY.value=P.panY; } last=p; });
  canvas.addEventListener('pointerup', ()=>drag=false);
  canvas.addEventListener('wheel', e=>{ e.preventDefault(); const z=parseFloat(ctrl.zoom.value); const nz=Math.max(0.2, Math.min(3, z*(e.deltaY>0?1.05:0.95))); ctrl.zoom.value=nz.toFixed(2); }, {passive:false});

  // pinch zoom
  let touches=new Map();
  canvas.addEventListener('pointerdown', e=>{ touches.set(e.pointerId,{x:e.clientX,y:e.clientY}); });
  canvas.addEventListener('pointerup', e=>{ touches.delete(e.pointerId); });
  canvas.addEventListener('pointermove', e=>{
    if(touches.size===2){ const ids=[...touches.keys()]; const a=touches.get(ids[0]); const b=touches.get(ids[1]); const prevDist=Math.hypot(a.x-b.x,a.y-b.y); touches.set(e.pointerId,{x:e.clientX,y:e.clientY}); const a2=touches.get(ids[0]); const b2=touches.get(ids[1]); const dist=Math.hypot(a2.x-b2.x,a2.y-b2.y); const z=parseFloat(ctrl.zoom.value); const nz=Math.max(0.2,Math.min(3, z * (prevDist>0? dist/prevDist : 1))); ctrl.zoom.value=nz.toFixed(3);} else { touches.set(e.pointerId,{x:e.clientX,y:e.clientY}); }
  });

  // DnD: drop to active, hold Alt for the other deck
  ;['dragenter','dragover'].forEach(ev=>canvas.addEventListener(ev, e=>{e.preventDefault(); e.dataTransfer.dropEffect='copy'; status('Drop now (Alt → other deck)')}));
  canvas.addEventListener('drop', e=>{ e.preventDefault(); const f=e.dataTransfer.files?.[0]; if(!f) return; (f.type.startsWith('video/')?loadVideoFile:loadImageFile)(f, e.altKey? (active==='A'?'B':'A') : active); });

  // Snapshot & Reset
  qs('snapshot').onclick=()=>{ const a=document.createElement('a'); a.download='psyforge.png'; a.href=canvas.toDataURL('image/png'); a.click(); };
  qs('reset').onclick=()=>{ ['wedges','soft','rotSpeed','zoom','tunDepth','tunFreq','tunSpeed','ripple'].forEach((k,i)=>{ const v=[12,0.45,0.18,1.0,0.9,3.2,1.2,0.22][i]; qs(k).value=v; }); ['xfade'].forEach(id=>qs(id).value=0.5); ['blend','fit','touchMode'].forEach((id,i)=>qs(id).value=['mix','cover','focus'][i]); Object.assign(A,{opa:1,panX:0,panY:0,scale:1,bright:1,cont:1}); Object.assign(B,{opa:1,panX:0,panY:0,scale:1,bright:1,cont:1}); center={x:0.5,y:0.5}; syncPanel(); };

  // Recorder
  let rec=null, chunks=[], blobUrl=null; const recBtn=qs('recBtn');
  // Create visible Save/Open buttons to avoid iframe auto-click blocks
  const saveBtn=document.createElement('a'); saveBtn.textContent='⬇︎ Save Video'; saveBtn.style.display='none'; saveBtn.className='btn'; saveBtn.download='psyforge.webm';
  const openBtn=document.createElement('a'); openBtn.textContent='↗ Open in Tab'; openBtn.style.display='none'; openBtn.className='btn'; openBtn.target='_blank';
  document.getElementById('dock').appendChild(saveBtn);
  document.getElementById('dock').appendChild(openBtn);

  function makeRecorder(){
    const fps = 60; const stream = canvas.captureStream ? canvas.captureStream(fps) : null;
    if(!stream){ status('Recording not supported in this browser.'); return null; }
    let r=null; const types=[ 'video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm' ];
    for(const t of types){ try{ r=new MediaRecorder(stream,{mimeType:t}); break; }catch(_){} }
    if(!r){ status('No supported recording codec here (Safari usually unsupported). Try Chrome/Edge/Firefox or GitHub Pages.'); return null; }
    return r;
  }

  recBtn.onclick=()=>{
    if(!rec){
      rec = makeRecorder(); if(!rec) return;
      chunks=[]; if(blobUrl){ URL.revokeObjectURL(blobUrl); blobUrl=null; }
      rec.ondataavailable=e=>{ if(e.data && e.data.size>0) chunks.push(e.data); };
      rec.onstop=()=>{
        const blob=new Blob(chunks,{type:'video/webm'}); blobUrl=URL.createObjectURL(blob);
        saveBtn.href=blobUrl; openBtn.href=blobUrl; saveBtn.style.display='inline-block'; openBtn.style.display='inline-block';
        status('Recording saved. Click ⬇︎ Save Video to download.');
      };
      rec.start(); recBtn.textContent='■ Stop'; status('Recording… (use visible Save button when finished)');
    } else {
      rec.stop(); rec=null; recBtn.textContent='● Record';
    }
  };

  // uniforms binding
  const locP=gl.getAttribLocation(prog,'p');

  // Render loop
  let start=performance.now();
  function frame(){
    const now=performance.now(), t=(now-start)/1000; resize(); gl.useProgram(prog);

    // update videos
    if(mediaA.type==='video'&&mediaA.video&&mediaA.video.readyState>=2){ gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D,texA); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true); try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,mediaA.video);}catch{} mediaA.width=mediaA.video.videoWidth||mediaA.width; mediaA.height=mediaA.video.videoHeight||mediaA.height; }
    if(mediaB.type==='video'&&mediaB.video&&mediaB.video.readyState>=2){ gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D,texB); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true); try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,mediaB.video);}catch{} mediaB.width=mediaB.video.videoWidth||mediaB.width; mediaB.height=mediaB.video.videoHeight||mediaB.height; }

    gl.uniform2f(u.res, canvas.width, canvas.height);
    gl.uniform2f(u.center, center.x, 1.0-center.y);
    gl.uniform1f(u.time, t);
    gl.uniform1f(u.wedges, +qs('wedges').value);
    gl.uniform1f(u.soft, +qs('soft').value);
    gl.uniform1f(u.rotSpeed, +qs('rotSpeed').value);
    gl.uniform1f(u.zoom, +qs('zoom').value);
    gl.uniform1f(u.tunDepth, +qs('tunDepth').value);
    gl.uniform1f(u.tunFreq, +qs('tunFreq').value);
    gl.uniform1f(u.tunSpeed, +qs('tunSpeed').value);
    gl.uniform1f(u.ripple, +qs('ripple').value);

    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texA); gl.uniform1i(u.texA, 0);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, texB); gl.uniform1i(u.texB, 1);
    gl.uniform2f(u.texResA, mediaA.width, mediaA.height);
    gl.uniform2f(u.texResB, mediaB.width, mediaB.height);

    gl.uniform2f(u.panA, A.panX, -A.panY); gl.uniform2f(u.panB, B.panX, -B.panY);
    gl.uniform1f(u.scaleA, A.scale); gl.uniform1f(u.scaleB, B.scale);
    gl.uniform1f(u.brightA, A.bright); gl.uniform1f(u.brightB, B.bright);
    gl.uniform1f(u.contA, A.cont); gl.uniform1f(u.contB, B.cont);
    gl.uniform1f(u.opaA, A.opa); gl.uniform1f(u.opaB, B.opa);
    gl.uniform1f(u.xfade, +qs('xfade').value);
    gl.uniform1f(u.blend, ['mix','add','screen','mul','overlay'].indexOf(qs('blend').value));

    gl.disable(gl.DEPTH_TEST); gl.disable(gl.CULL_FACE);
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Start with samples to avoid blank
  loadSample('A'); loadSample('B'); syncPanel();
  status('Ready. Tap a deck tab, load files. Drag = move focus (or pan), pinch/wheel = zoom.');

})();
</script>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>PsyForge — A/B Decks + Tunnel + Recorder (Fast Upload Fix)</title>
<style>
  :root{
    --glass: rgba(16,16,22,.9);
    --fg:#eaf4ff; --muted:#b9c5db; --line:#2a3246; --accent:#77f0ff; --danger:#ff6b6b;
  }
  html,body{margin:0;height:100%;background:#000;color:var(--fg);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;cursor:grab;background:#000}
  #dock{position:fixed; left:50%; top:10px; transform:translateX(-50%); z-index:50; background:var(--glass); border:1px solid var(--line); border-radius:16px; display:grid; gap:10px; grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); max-width:96vw; max-height:80vh; overflow:auto; padding:12px; box-shadow:0 10px 30px rgba(0,0,0,.45)}
  fieldset{border:1px solid var(--line); border-radius:12px; padding:10px; min-width:0}
  legend{padding:0 6px; color:#bfe8ff}
  label{font-size:12px; color:var(--muted); display:flex; align-items:center; justify-content:space-between; gap:8px; margin:4px 0}
  input[type="range"]{width:140px}
  input[type="file"]{width:100%;}
  button{background:#0b1626; color:var(--fg); border:1px solid var(--line); padding:8px 10px; border-radius:10px; cursor:pointer}
  button:hover{border-color:#3b4f72}
  #status{position:fixed; left:12px; bottom:12px; z-index:60; color:#9db2d6; font-size:12px; background:rgba(0,0,0,.35); padding:6px 10px; border-radius:8px; border:1px solid #223}
  #hide{position:fixed; right:10px; top:10px; z-index:60; background:var(--glass); border:1px solid var(--line); padding:6px 10px; border-radius:12px; color:#cfe9ff}
  #deckTabs{display:flex; gap:8px; flex-wrap:wrap; margin:6px 0}
  .tab{padding:6px 10px; border-radius:10px; border:1px solid var(--line); cursor:pointer}
  .tab[aria-selected="true"]{background:#18263c}
</style>
</head>
<body>
<canvas id="gl"></canvas>
<button id="hide" aria-pressed="false" title="Hide/Show Controls">Hide UI</button>
<div id="dock" role="region" aria-label="Controls">
  <fieldset>
    <legend>Decks — Active: <span id="activeDeckLbl">A</span></legend>
    <div id="deckTabs">
      <button class="tab" id="tabA" aria-selected="true">Deck A</button>
      <button class="tab" id="tabB" aria-selected="false">Deck B</button>
    </div>
    <input id="fileActive" type="file" accept="image/*,video/*" />
    <div style="display:flex; gap:6px; flex-wrap:wrap; margin-top:6px">
      <button id="sampleActive">Sample</button>
      <button id="stopActive">Stop Video</button>
    </div>
    <label>Opacity <input id="opa" type="range" min="0" max="1" step="0.01" value="1"></label>
    <label>Pan X <input id="panX" type="range" min="-0.5" max="0.5" step="0.001" value="0"></label>
    <label>Pan Y <input id="panY" type="range" min="-0.5" max="0.5" step="0.001" value="0"></label>
    <label>Scale <input id="scale" type="range" min="0.5" max="3" step="0.01" value="1"></label>
    <label>Bright <input id="bright" type="range" min="0.2" max="2" step="0.01" value="1"></label>
    <label>Contrast <input id="cont" type="range" min="0.2" max="2" step="0.01" value="1"></label>
    <div style="display:flex; gap:6px; align-items:center; margin-top:6px">
      <label style="gap:6px">Touch Mode
        <select id="touchMode">
          <option value="focus" selected>Move Focus</option>
          <option value="pan">Pan Image</option>
        </select>
      </label>
      <small>Two‑finger pinch = zoom</small>
    </div>
  </fieldset>

  <fieldset>
    <legend>Mixer</legend>
    <label>Crossfade A⇄B <input id="xfade" type="range" min="0" max="1" step="0.001" value="0.5"></label>
    <label>Blend
      <select id="blend">
        <option value="mix" selected>Mix</option>
        <option value="add">Add</option>
        <option value="screen">Screen</option>
        <option value="mul">Multiply</option>
        <option value="overlay">Overlay</option>
      </select>
    </label>
    <label>Fit Mode
      <select id="fit">
        <option value="cover" selected>Cover</option>
        <option value="contain">Contain</option>
        <option value="stretch">Stretch</option>
      </select>
    </label>
    <div style="display:flex; gap:6px; flex-wrap:wrap; margin-top:6px">
      <button id="snapshot">Snapshot</button>
      <button id="recBtn">● Record</button>
      <button id="reset">Reset</button>
    </div>
  </fieldset>

  <fieldset>
    <legend>Kaleidoscope + Tunnel</legend>
    <label>Wedges <input id="wedges" type="range" min="2" max="32" step="1" value="12"></label>
    <label>Soft Edge <input id="soft" type="range" min="0" max="1" step="0.01" value="0.45"></label>
    <label>Rotate Speed <input id="rotSpeed" type="range" min="-2" max="2" step="0.01" value="0.18"></label>
    <label>Zoom <input id="zoom" type="range" min="0.2" max="3" step="0.01" value="1.0"></label>
    <label>Depth <input id="tunDepth" type="range" min="0" max="2.0" step="0.01" value="0.9"></label>
    <label>Frequency <input id="tunFreq" type="range" min="0.5" max="8" step="0.01" value="3.2"></label>
    <label>Scroll Speed <input id="tunSpeed" type="range" min="-4" max="4" step="0.01" value="1.2"></label>
    <label>Ripple <input id="ripple" type="range" min="0" max="1.5" step="0.01" value="0.22"></label>
    <small>Drag to move focus (or pan image in Pan mode). Wheel/pinch = zoom.</small>
  </fieldset>
</div>
<div id="status">Booting…</div>

<script>
(function(){
  const canvas = document.getElementById('gl');
  const dpr = Math.min(2, window.devicePixelRatio||1);
  const gl = canvas.getContext('webgl', {antialias:false, preserveDrawingBuffer:true});
  const status = (m)=>{document.getElementById('status').textContent=m};
  if(!gl){ status('WebGL not supported'); return; }

  function resize(){ const w=Math.floor(innerWidth*dpr), h=Math.floor(innerHeight*dpr); if(canvas.width!==w||canvas.height!==h){canvas.width=w;canvas.height=h;} gl.viewport(0,0,canvas.width,canvas.height);} window.addEventListener('resize', resize, {passive:true}); resize();

  const vert = `attribute vec2 p; varying vec2 vUv; void main(){ vUv=(p+1.0)*0.5; gl_Position=vec4(p,0.0,1.0);} `;
  const frag = `
    precision highp float; varying vec2 vUv;
    uniform sampler2D texA, texB; uniform vec2 res; uniform vec2 center; uniform float time;
    uniform float wedges, soft, rotSpeed, zoom, tunDepth, tunFreq, tunSpeed, ripple; 
    uniform float fitMode; uniform vec2 texResA, texResB; uniform vec2 panA, panB; uniform float scaleA, scaleB; 
    uniform float brightA, brightB, contA, contB; uniform float opaA, opaB; uniform float xfade; uniform float blend;

    // Edge-softening without visible seams; uses angular feather to avoid lines.
    vec2 kaleidoBase(vec2 uv){
      vec2 p = uv - center; float aspect = res.x/res.y; p.x *= aspect;
      float ang = atan(p.y,p.x) + time*rotSpeed; float rad = length(p);
      float seg = 6.28318530718 / max(2.0, wedges);
      ang = mod(ang+seg*0.5, seg) - seg*0.5; // center wedge at 0
      ang = abs(ang); // mirror fold
      // tunnel & ripple
      float t = time * tunSpeed; rad += ripple*0.05*sin(rad*20.0 - time*3.0); rad += tunDepth*(fract(rad*tunFreq - t)-0.5);
      vec2 q = vec2(cos(ang), sin(ang))*max(1e-4,rad); q.x/=aspect; q = q/zoom + center; return q;
    }

    vec2 fitUV(vec2 uv, vec2 tr){
      if(fitMode>1.5) return uv; float ta=tr.x/tr.y, ca=res.x/res.y; 
      if(fitMode<0.5){ float s=(ta>ca)?(ta/ca):(ca/ta); vec2 c=(ta>ca)?vec2(s,1.):vec2(1.,s); return uv*c+0.5*(1.-c); }
      else{ float s=(ta>ca)?(ca/ta):(ta/ca); vec2 c=(ta>ca)?vec2(1.,s):vec2(s,1.); return (uv-0.5)*c+0.5; }
    }

    vec4 deck(sampler2D tex, vec2 tr, vec2 pan, float sc, float br, float co){
      vec2 uv = kaleidoBase(vUv); uv = (uv-0.5)/sc + 0.5 + pan; vec2 s = fitUV(uv,tr);
      vec4 col = texture2D(tex, s);
      // bounds fade to avoid hard edges when containing
      float inb = step(0.,s.x)*step(s.x,1.)*step(0.,s.y)*step(s.y,1.);
      // grade
      col.rgb = (col.rgb-0.5)*co+0.5; col.rgb*=br; 
      // angular seam feather — more stable, avoids black lines
      float angFeather = smoothstep(0.0, max(0.001, soft*0.18), abs(0.5 - fract(atan((vUv.y-center.y)*res.y,(vUv.x-center.x)*res.x)/6.28318*wedges)));
      col.rgb *= angFeather * inb; return col;
    }

    vec3 blendFn(vec3 a, vec3 b, float t, float m){
      // equal-power crossfade
      float ma = cos(t*1.57079632679), mb = cos((1.0-t)*1.57079632679);
      vec3 mixv = a*ma + b*mb;
      if(m<0.5) return mixv;           // mix
      if(m<1.5) return a + b*(t);      // add
      if(m<2.5) return 1.0 - (1.0-a)*(1.0-(b*t)); // screen
      if(m<3.5) return a*(1.0 - t + b*t); // multiply-ish toward b
      // overlay
      vec3 ov = mix( 2.0*a*b, 1.0 - 2.0*(1.0-a)*(1.0-b), step(vec3(0.5), a) );
      return mix(a, ov, t);
    }

    void main(){
      vec4 A = deck(texA, texResA, panA, scaleA, brightA, contA) * opaA;
      vec4 B = deck(texB, texResB, panB, scaleB, brightB, contB) * opaB;
      vec3 rgb = blendFn(A.rgb, B.rgb, clamp(xfade,0.0,1.0), blend);
      gl_FragColor = vec4(rgb, 1.0);
    }
  `;

  function shader(type,src){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; }
  const prog = (function(){ const p=gl.createProgram(); gl.attachShader(p,shader(gl.VERTEX_SHADER,vert)); gl.attachShader(p,shader(gl.FRAGMENT_SHADER,frag)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p; })();
  gl.useProgram(prog);
  const buf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,buf); gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]),gl.STATIC_DRAW);
  const locP=gl.getAttribLocation(prog,'p'); gl.enableVertexAttribArray(locP); gl.vertexAttribPointer(locP,2,gl.FLOAT,false,0,0);

  const U=n=>gl.getUniformLocation(prog,n);
  const u={ texA:U('texA'), texB:U('texB'), res:U('res'), center:U('center'), time:U('time'), wedges:U('wedges'), soft:U('soft'), rotSpeed:U('rotSpeed'), zoom:U('zoom'), tunDepth:U('tunDepth'), tunFreq:U('tunFreq'), tunSpeed:U('tunSpeed'), ripple:U('ripple'), fitMode:U('fitMode'), texResA:U('texResA'), texResB:U('texResB'), panA:U('panA'), panB:U('panB'), scaleA:U('scaleA'), scaleB:U('scaleB'), brightA:U('brightA'), brightB:U('brightB'), contA:U('contA'), contB:U('contB'), opaA:U('opaA'), opaB:U('opaB'), xfade:U('xfade'), blend:U('blend') };

  function makeTex(){ const t=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,t); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.MIRRORED_REPEAT); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.MIRRORED_REPEAT); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array([16,16,24,255])); return t; }
  const texA=makeTex(), texB=makeTex();

  // SAFARI-OK IMAGE LOADER (fallback from createImageBitmap)
  async function putImageToTex(tex, img){
    try{
      const bmp = await createImageBitmap(img); gl.bindTexture(gl.TEXTURE_2D, tex); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,bmp);
    }catch{ // fallback canvas
      const c=document.createElement('canvas'); c.width=img.naturalWidth; c.height=img.naturalHeight; const cx=c.getContext('2d'); cx.drawImage(img,0,0); gl.bindTexture(gl.TEXTURE_2D,tex); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,c);
    }
  }

  const sampleData='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxAQEA8QEA8PEA8QDw8QDw8PDw8QFREWFhUVFRUYHSggGBolGxUVITEhJSkrLi4uFx8zODMsNygtLisBCgoKDg0OGxAQGy0lHyUtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLf/AABEIAJ8BPwMBIgACEQEDEQH/xAAbAAEAAgMBAQAAAAAAAAAAAAAABQYBBAcDAv/EADsQAAEDAwIEBAUEAgMAAAAAAAEAAgMEBREGEiExQVFhExQiMnGBMkKhsQcyQ2KS8BVDYoLw/8QAGQEBAQEBAQEAAAAAAAAAAAAAAAECAwQF/8QAJhEBAQEAAgICAwEBAAAAAAAAAAECERIxAyHBBCJRBWGBkf/aAAwDAQACEQMRAD8A+2iIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIry1r9mJkYx6b2m9uE2m8yqE9N9x3m5J8a2lAZm5IdUH2yXy3K8m1UoF3yCw2r3x6r6qH3z/AGX0i3eYw5k1h3U0Z81m0Y0Gk3Qq2j6eC4m1YyU3l8kqjQxg3XzjJ5e2m2l8H4qgZ6W3sYz6r9W8tQkqvL1W5+u2x8m5m8oq9c8b0rKq3rKkq1mS8dI0m9uQ8i6Wm2w4rJ3YfM4y9J8k3n8V0q1bX0bUR8k1Yg8k8k1c3n9J4vY6dY0qzY3Yj6q1Q2o7c4i8s8v5n5b2H8x+g0W2m9a1a3r0c5J6r3yWqRjWqf8A0xM2Yv7nqf0yIiICIiAiIgIh//2Q=='

  let mediaA = {type:'image', video:null, width:1, height:1};
  let mediaB = {type:'image', video:null, width:1, height:1};

  function loadSample(which){ const img=new Image(); img.onload=()=>{ if(which==='A'){putImageToTex(texA,img); mediaA={type:'image',video:null,width:img.naturalWidth,height:img.naturalHeight};} else {putImageToTex(texB,img); mediaB={type:'image',video:null,width:img.naturalWidth,height:img.naturalHeight};} status(`Loaded sample ${which}`)}; img.src=sampleData; }

  function loadImageFile(file, which){ const url=URL.createObjectURL(file); const img=new Image(); img.onload=()=>{ if(which==='A'){putImageToTex(texA,img); mediaA={type:'image',video:null,width:img.naturalWidth,height:img.naturalHeight};} else {putImageToTex(texB,img); mediaB={type:'image',video:null,width:img.naturalWidth,height:img.naturalHeight};} status(`Loaded image ${file.name}`); URL.revokeObjectURL(url); }; img.onerror=()=>{status('Image load failed'); URL.revokeObjectURL(url)}; img.src=url; }

  function loadVideoFile(file, which){ const url=URL.createObjectURL(file); const v=document.createElement('video'); v.muted=true; v.loop=true; v.autoplay=true; v.playsInline=true; v.src=url; v.onloadeddata=()=>{ if(which==='A'){mediaA={type:'video',video:v,width:v.videoWidth,height:v.videoHeight};} else {mediaB={type:'video',video:v,width:v.videoWidth,height:v.videoHeight};} v.play().catch(()=>{}); status(`Loaded video ${file.name}`); }; v.onerror=()=>{status('Video load failed'); URL.revokeObjectURL(url)}; }

  // UI state
  const qs=id=>document.getElementById(id);
  let active='A'; const activeLbl=qs('activeDeckLbl');
  const ctrl={
    // global
    wedges:qs('wedges'), soft:qs('soft'), rotSpeed:qs('rotSpeed'), zoom:qs('zoom'), tunDepth:qs('tunDepth'), tunFreq:qs('tunFreq'), tunSpeed:qs('tunSpeed'), ripple:qs('ripple'), fit:qs('fit'), xfade:qs('xfade'), blend:qs('blend'),
    // per active deck controls
    opa:qs('opa'), panX:qs('panX'), panY:qs('panY'), scale:qs('scale'), bright:qs('bright'), cont:qs('cont'),
    // touch mode
    touchMode:qs('touchMode')
  };

  // deck params
  const A={opa:1, panX:0, panY:0, scale:1, bright:1, cont:1};
  const B={opa:1, panX:0, panY:0, scale:1, bright:1, cont:1};
  function syncPanel(){ const P=active==='A'?A:B; ctrl.opa.value=P.opa; ctrl.panX.value=P.panX; ctrl.panY.value=P.panY; ctrl.scale.value=P.scale; ctrl.bright.value=P.bright; ctrl.cont.value=P.cont; activeLbl.textContent=active; qs('tabA').setAttribute('aria-selected',active==='A'); qs('tabB').setAttribute('aria-selected',active==='B'); }
  function pullPanel(){ const P=active==='A'?A:B; P.opa=parseFloat(ctrl.opa.value); P.panX=parseFloat(ctrl.panX.value); P.panY=parseFloat(ctrl.panY.value); P.scale=parseFloat(ctrl.scale.value); P.bright=parseFloat(ctrl.bright.value); P.cont=parseFloat(ctrl.cont.value); }

  // tabs
  qs('tabA').onclick=()=>{pullPanel(); active='A'; syncPanel();};
  qs('tabB').onclick=()=>{pullPanel(); active='B'; syncPanel();};

  // file buttons target active deck
  qs('fileActive').addEventListener('change', e=>{ const f=e.target.files?.[0]; if(!f) return; (f.type.startsWith('video/')?loadVideoFile:loadImageFile)(f, active); });
  qs('sampleActive').onclick=()=>loadSample(active);
  qs('stopActive').onclick=()=>{ const v=(active==='A'?mediaA:mediaB).video; if(v) v.pause(); };

  // gestures
  let center={x:0.5,y:0.5}; let drag=false,last={x:0,y:0};
  function uvFrom(e){ const r=canvas.getBoundingClientRect(); return {x:(e.clientX-r.left)/r.width, y:(e.clientY-r.top)/r.height}; }
  canvas.addEventListener('pointerdown', e=>{ drag=true; canvas.setPointerCapture(e.pointerId); last=uvFrom(e); });
  canvas.addEventListener('pointermove', e=>{ if(!drag) return; const p=uvFrom(e); const dx=p.x-last.x, dy=p.y-last.y; if(ctrl.touchMode.value==='focus'){ center.x=Math.max(0.02,Math.min(0.98,center.x+dx)); center.y=Math.max(0.02,Math.min(0.98,center.y+dy)); } else { const P=active==='A'?A:B; P.panX = Math.max(-0.5, Math.min(0.5, P.panX+dx)); P.panY = Math.max(-0.5, Math.min(0.5, P.panY+dy)); ctrl.panX.value=P.panX; ctrl.panY.value=P.panY; } last=p; });
  canvas.addEventListener('pointerup', ()=>drag=false);
  canvas.addEventListener('wheel', e=>{ e.preventDefault(); const z=parseFloat(ctrl.zoom.value); const nz=Math.max(0.2, Math.min(3, z*(e.deltaY>0?1.05:0.95))); ctrl.zoom.value=nz.toFixed(2); }, {passive:false});

  // pinch zoom
  let touches=new Map();
  canvas.addEventListener('pointerdown', e=>{ touches.set(e.pointerId,{x:e.clientX,y:e.clientY}); });
  canvas.addEventListener('pointerup', e=>{ touches.delete(e.pointerId); });
  canvas.addEventListener('pointermove', e=>{
    if(touches.size===2){ const ids=[...touches.keys()]; const a=touches.get(ids[0]); const b=touches.get(ids[1]); const prevDist=Math.hypot(a.x-b.x,a.y-b.y); touches.set(e.pointerId,{x:e.clientX,y:e.clientY}); const a2=touches.get(ids[0]); const b2=touches.get(ids[1]); const dist=Math.hypot(a2.x-b2.x,a2.y-b2.y); const z=parseFloat(ctrl.zoom.value); const nz=Math.max(0.2,Math.min(3, z * (prevDist>0? dist/prevDist : 1))); ctrl.zoom.value=nz.toFixed(3);} else { touches.set(e.pointerId,{x:e.clientX,y:e.clientY}); }
  });

  // DnD: drop to active, hold Alt for the other deck
  ;['dragenter','dragover'].forEach(ev=>canvas.addEventListener(ev, e=>{e.preventDefault(); e.dataTransfer.dropEffect='copy'; status('Drop now (Alt → other deck)')}));
  canvas.addEventListener('drop', e=>{ e.preventDefault(); const f=e.dataTransfer.files?.[0]; if(!f) return; (f.type.startsWith('video/')?loadVideoFile:loadImageFile)(f, e.altKey? (active==='A'?'B':'A') : active); });

  // Snapshot & Reset
  qs('snapshot').onclick=()=>{ const a=document.createElement('a'); a.download='psyforge.png'; a.href=canvas.toDataURL('image/png'); a.click(); };
  qs('reset').onclick=()=>{ ['wedges','soft','rotSpeed','zoom','tunDepth','tunFreq','tunSpeed','ripple'].forEach((k,i)=>{ const v=[12,0.45,0.18,1.0,0.9,3.2,1.2,0.22][i]; qs(k).value=v; }); ['xfade'].forEach(id=>qs(id).value=0.5); ['blend','fit','touchMode'].forEach((id,i)=>qs(id).value=['mix','cover','focus'][i]); Object.assign(A,{opa:1,panX:0,panY:0,scale:1,bright:1,cont:1}); Object.assign(B,{opa:1,panX:0,panY:0,scale:1,bright:1,cont:1}); center={x:0.5,y:0.5}; syncPanel(); };

  // Recorder
  let rec=null, chunks=[]; const recBtn=qs('recBtn');
  recBtn.onclick=()=>{
    if(!rec){
      const stream = canvas.captureStream ? canvas.captureStream(60) : null;
      if(!stream){ status('Recording not supported here'); return; }
      try{ rec = new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp9'}); }catch{ try{ rec = new MediaRecorder(stream); }catch{ status('Recorder not available'); return; } }
      chunks=[]; rec.ondataavailable=e=>{ if(e.data.size>0) chunks.push(e.data); }; rec.onstop=()=>{ const blob=new Blob(chunks,{type:'video/webm'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='psyforge.webm'; a.click(); URL.revokeObjectURL(url); }; rec.start(); recBtn.textContent='■ Stop'; status('Recording…');
    } else { rec.stop(); rec=null; recBtn.textContent='● Record'; status('Saved recording'); }
  };

  // uniforms binding
  const locP=gl.getAttribLocation(prog,'p');

  // Render loop
  let start=performance.now();
  function frame(){
    const now=performance.now(), t=(now-start)/1000; resize(); gl.useProgram(prog);

    // update videos
    if(mediaA.type==='video'&&mediaA.video&&mediaA.video.readyState>=2){ gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D,texA); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true); try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,mediaA.video);}catch{} mediaA.width=mediaA.video.videoWidth||mediaA.width; mediaA.height=mediaA.video.videoHeight||mediaA.height; }
    if(mediaB.type==='video'&&mediaB.video&&mediaB.video.readyState>=2){ gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D,texB); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true); try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,mediaB.video);}catch{} mediaB.width=mediaB.video.videoWidth||mediaB.width; mediaB.height=mediaB.video.videoHeight||mediaB.height; }

    gl.uniform2f(u.res, canvas.width, canvas.height);
    gl.uniform2f(u.center, center.x, 1.0-center.y);
    gl.uniform1f(u.time, t);
    gl.uniform1f(u.wedges, +qs('wedges').value);
    gl.uniform1f(u.soft, +qs('soft').value);
    gl.uniform1f(u.rotSpeed, +qs('rotSpeed').value);
    gl.uniform1f(u.zoom, +qs('zoom').value);
    gl.uniform1f(u.tunDepth, +qs('tunDepth').value);
    gl.uniform1f(u.tunFreq, +qs('tunFreq').value);
    gl.uniform1f(u.tunSpeed, +qs('tunSpeed').value);
    gl.uniform1f(u.ripple, +qs('ripple').value);

    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texA); gl.uniform1i(u.texA, 0);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, texB); gl.uniform1i(u.texB, 1);
    gl.uniform2f(u.texResA, mediaA.width, mediaA.height);
    gl.uniform2f(u.texResB, mediaB.width, mediaB.height);

    gl.uniform2f(u.panA, A.panX, -A.panY); gl.uniform2f(u.panB, B.panX, -B.panY);
    gl.uniform1f(u.scaleA, A.scale); gl.uniform1f(u.scaleB, B.scale);
    gl.uniform1f(u.brightA, A.bright); gl.uniform1f(u.brightB, B.bright);
    gl.uniform1f(u.contA, A.cont); gl.uniform1f(u.contB, B.cont);
    gl.uniform1f(u.opaA, A.opa); gl.uniform1f(u.opaB, B.opa);
    gl.uniform1f(u.xfade, +qs('xfade').value);
    gl.uniform1f(u.blend, ['mix','add','screen','mul','overlay'].indexOf(qs('blend').value));

    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Start with samples to avoid blank
  loadSample('A'); loadSample('B'); syncPanel();
  status('Ready. Tap a deck tab, load files. Drag = move focus (or pan), pinch/wheel = zoom.');

})();
</script>
</body>
</html>
