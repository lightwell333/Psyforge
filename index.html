  function fit(){ const dpr=Math.max(1,Math.min(2,devicePixelRatio||1)); const w=Math.floor(innerWidth*dpr), h=Math.floor(innerHeight*dpr); if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h; } gl.viewport(0,0,w,h); gl.uniform2f(U.u_res,w,h); }
  addEventListener('resize', fit, {passive:true}); fit();
  function tickMedia(){ if(!vidA.paused && vidA.currentTime>0 && !vidA.ended) bakeTo(texA,vidA); if(!vidB.paused && vidB.currentTime>0 && !vidB.ended) bakeTo(texB,vidB); }

  let tPrev=performance.now()/1000, rot=0; function draw(){ requestAnimationFrame(draw); fit(); const t=performance.now()/1000; const dt=t - tPrev; tPrev=t; rot += +rotR.value * dt; tickMedia(); gl.uniform1f(U.u_time,t); gl.uniform1f(U.u_k,+kR.value); gl.uniform1f(U.u_zoom,+zoomR.value); gl.uniform2f(U.u_pan,pan.x,pan.y); gl.uniform1f(U.u_rot,rot); gl.uniform1f(U.u_mix,+mixR.value); gl.uniform1i(U.u_hasA, hasA?1:0); gl.uniform1i(U.u_hasB, hasB?1:0); gl.uniform1f(U.u_twistA,+A.twist.value); gl.uniform1f(U.u_twistB,+B.twist.value); gl.uniform1f(U.u_bulgeA,+A.bulge.value); gl.uniform1f(U.u_bulgeB,+B.bulge.value); gl.uniform1f(U.u_rAmpA,+A.rAmp.value); gl.uniform1f(U.u_rAmpB,+B.rAmp.value); gl.uniform1f(U.u_rFreqA,+A.rFreq.value); gl.uniform1f(U.u_rFreqB,+B.rFreq.value); gl.uniform1f(U.u_rSpdA,+A.rSpd.value); gl.uniform1f(U.u_rSpdB,+B.rSpd.value); gl.uniform1f(U.u_swirlA,+A.swirl.value); gl.uniform1f(U.u_swirlB,+B.swirl.value); gl.uniform1f(U.u_hueA,+A.hue.value); gl.uniform1f(U.u_hueB,+B.hue.value); gl.uniform1f(U.u_satA,+A.sat.value); gl.uniform1f(U.u_satB,+B.sat.value); gl.uniform1f(U.u_gainA,+A.gain.value); gl.uniform1f(U.u_gainB,+B.gain.value); gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES,0,6); }
  draw();

  // Drag & drop + paste
  ;['dragenter','dragover'].forEach(ev=>canvas.addEventListener(ev,(e)=>{ e.preventDefault(); }));
  canvas.addEventListener('drop',(e)=>{ e.preventDefault(); const f=e.dataTransfer.files?.[0]; if(!f) return; handleFile('A', f); });
  document.addEventListener('paste', (e)=>{ const item=[...(e.clipboardData?.items||[])].find(i=>i.type.startsWith('image/')); if(!item) return; const f=item.getAsFile(); if(f) handleFile('A', f); });

  // ======= AUDIO (A/B) =======
  const audA=document.getElementById('audA');
  const audB=document.getElementById('audB');
  const loadAudA=document.getElementById('loadAudA');
  const loadAudB=document.getElementById('loadAudB');
  const audFileA=document.getElementById('audFileA');
  const audFileB=document.getElementById('audFileB');
  const playA=document.getElementById('playA');
  const playB=document.getElementById('playB');
  const volA=document.getElementById('volA');
  const volB=document.getElementById('volB');
  const master=document.getElementById('master');

  let AC=null, masterGain, gainA, gainB, xfadeA, xfadeB, srcA=null, srcB=null;
  function ensureAC(){ if(AC) return; AC=new (window.AudioContext||window.webkitAudioContext)(); masterGain=AC.createGain(); masterGain.gain.value=+master.value; gainA=AC.createGain(); gainB=AC.createGain(); xfadeA=AC.createGain(); xfadeB=AC.createGain(); // crossfade law via mixR input
    // wiring: srcA -> gainA -> xfadeA -> master; srcB -> gainB -> xfadeB -> master
    xfadeA.connect(masterGain); xfadeB.connect(masterGain); masterGain.connect(AC.destination);
    volA.addEventListener('input', ()=> gainA.gain.value=+volA.value);
    volB.addEventListener('input', ()=> gainB.gain.value=+volB.value);
    master.addEventListener('input', ()=> masterGain.gain.value=+master.value);
    mixR.addEventListener('input', updateXfade); updateXfade();
  }
  function updateXfade(){ const t=+mixR.value; // 0..1
    const a=Math.cos(t*Math.PI*0.5); const b=Math.sin(t*Math.PI*0.5); if(xfadeA&&xfadeB){ xfadeA.gain.value=a; xfadeB.gain.value=b; } }
  function connectIfNeeded(which){ ensureAC(); if(which==='A' && !srcA){ srcA=AC.createMediaElementSource(audA); srcA.connect(gainA).connect(xfadeA); } if(which==='B' && !srcB){ srcB=AC.createMediaElementSource(audB); srcB.connect(gainB).connect(xfadeB); } }

  loadAudA.onclick=()=>audFileA.click();
  loadAudB.onclick=()=>audFileB.click();
  audFileA.onchange=(e)=>{ const f=e.target.files[0]; if(!f) return; const url=URL.createObjectURL(f); audA.src=url; audA.load(); statusMsg('Audio → Deck A'); };
  audFileB.onchange=(e)=>{ const f=e.target.files[0]; if(!f) return; const url=URL.createObjectURL(f); audB.src=url; audB.load(); statusMsg('Audio → Deck B'); };
  playA.onclick=async()=>{ connectIfNeeded('A'); if(audA.paused){ try{ await audA.play(); }catch{} } else { audA.pause(); } if(AC?.state==='suspended') AC.resume(); };
  playB.onclick=async()=>{ connectIfNeeded('B'); if(audB.paused){ try{ await audB.play(); }catch{} } else { audB.pause(); } if(AC?.state==='suspended') AC.resume(); };

  // ===== Starter visual so it never looks blank =====
